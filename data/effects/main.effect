/**
 * @file main.effect
 * @brief Guided Image Filter and related utility shaders.
 * @date 2025-09-16
 * @author Kaito Udagawa
 *
 * This effect file contains all the necessary pixel shaders and techniques
 * for grayscale conversion, box filtering, and a multi-pass implementation
 * of the Guided Image Filter.
 */

// --- Uniforms (Variables set from the host application) ---

uniform float4x4 ViewProj; ///< View-projection matrix for the vertex shader.
uniform texture2d image;   ///< Primary input texture. Its role varies per pass.

// Parameters for the box filter
uniform float texelWidth;  ///< The width of a single texel (1.0 / texture_width).
uniform float texelHeight; ///< The height of a single texel (1.0 / texture_height).
uniform int kernelSize;    ///< The kernel size for the box filter (an odd number is recommended).

// Textures for multi-pass operations
uniform texture2d image1; ///< Secondary input texture.
uniform texture2d image2; ///< Tertiary input texture.
uniform texture2d image3; ///< Quaternary input texture.

// Parameters for the Guided Filter
uniform float eps; ///< A small epsilon value to prevent division by zero when calculating coefficient 'a'.

// --- Sampler States (How textures are sampled) ---

/// @brief Sampler with linear interpolation (Bilinear). Used for filtering and smooth scaling.
sampler_state linear_sampler
{
	Filter = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

/// @brief Sampler without interpolation (Nearest Neighbor). Used for precise data access.
sampler_state point_sampler
{
	Filter = Point;
	AddressU = Clamp;
	AddressV = Clamp;
};

/**
 * @brief Data structure passed from the vertex shader to the pixel shader.
 */
struct VertInOut {
	float4 pos : POSITION; ///< Clip-space position.
	float2 uv : TEXCOORD0; ///< UV texture coordinate.
};

/**
 * @brief A standard vertex shader that transforms vertex positions and passes UV coordinates through.
 */
VertInOut VSDefault(VertInOut vert_in)
{
	VertInOut vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv = vert_in.uv;
	return vert_out;
}

/**
 * @brief Draws the 'image' texture directly.
 */
float4 PSDraw(VertInOut vert_in) : TARGET
{
	return image.Sample(point_sampler, vert_in.uv);
}

/**
 * @brief Draws the final image by combining the RGB from 'image' and using the R channel of 'image1' as the alpha mask.
 * @param image The source texture for RGB color.
 * @param image1 The source texture for the alpha mask (uses the R channel).
 * @note 'image' and 'image1' are expected to be the same size.
 */
float4 PSDrawWithMask(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;
	float4 final_color;

	final_color.rgb = image.Sample(point_sampler, uv).rgb;
	final_color.a = image1.Sample(point_sampler, uv).r;

	return final_color;
}

float4 PSResampleByNearestR8(VertInOut vert_in) : TARGET
{
	float value = image.Sample(point_sampler, vert_in.uv).r;
	return float4(value, value, value, 1.0f);
}

/**
 * @brief Converts the 'image' texture to grayscale using the standard luma calculation.
 */
float4 PSConvertToGrayscale(VertInOut vert_in) : TARGET
{
	float4 color = image.Sample(point_sampler, vert_in.uv);
	float luma = dot(color.rgb, float3(0.2126, 0.7152, 0.0722));
	return float4(luma, luma, luma, 1.0f);
}

/**
 * @brief Applies an optimized 1D horizontal box filter with a fixed kernel size of 17.
 * (Pass 1 of a separable filter)
 */
float4 PSHorizontalBoxFilterR8KS17(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;
	float halfTexelWidth = texelWidth / 2.0f;

	float bilinear_sum = 0.0f;
	for (int i = 1; i <= 4; i++) {
		float2 offset = float2((i * 4 - 1) * halfTexelWidth, 0.0f);
		bilinear_sum += image.Sample(linear_sampler, uv + offset).r;
		bilinear_sum += image.Sample(linear_sampler, uv - offset).r;
	}

	float luma = (image.Sample(linear_sampler, uv).r + bilinear_sum * 2.0f) / 17.0f;

	return float4(luma, luma, luma, 1.0f);
}

/**
 * @brief Applies an optimized 1D horizontal box filter with a fixed kernel size of 17.
 * (Pass 1 of a separable filter)
 */
float4 PSHorizontalBoxFilterWithMulR8KS17(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

    float sum = image.Sample(linear_sampler, uv).r * image1.Sample(linear_sampler, uv).r;
    for (int i = 1; i <= 8; i++) {
        float2 offset = float2(i * texelWidth, 0.0f);
        sum += image.Sample(point_sampler, uv + offset).r * image1.Sample(linear_sampler, uv + offset).r;
        sum += image.Sample(point_sampler, uv - offset).r * image1.Sample(linear_sampler, uv - offset).r;
    }

	float luma = sum / 17.0f;

	return float4(luma, luma, luma, 1.0f);
}


float square(float x) {
    return x * x;
}

/**
 * @brief Applies an optimized 1D horizontal box filter with a fixed kernel size of 17.
 * (Pass 1 of a separable filter)
 */
float4 PSHorizontalBoxFilterWithSqR8KS17(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

    float sum = square(image.Sample(linear_sampler, uv).r);
    for (int i = 1; i <= 8; i++) {
        float2 offset = float2(i * texelWidth, 0.0f);
        sum += square(image.Sample(point_sampler, uv + offset).r);
        sum += square(image.Sample(point_sampler, uv - offset).r);
    }

	float luma = sum / 17.0f;

	return float4(luma, luma, luma, 1.0f);
}

/**
 * @brief Applies an optimized 1D vertical box filter with a fixed kernel size of 17.
 * (Pass 2 of a separable filter)
 */
float4 PSVerticalBoxFilterR8KS17(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;
	float halfTexelHeight = texelHeight / 2.0f;

	float bilinear_sum = 0.0f;
	for (int i = 1; i <= 4; i++) {
		float2 offset = float2(0.0f, (i * 4 - 1) * halfTexelHeight);
		bilinear_sum += image.Sample(linear_sampler, uv + offset).r;
		bilinear_sum += image.Sample(linear_sampler, uv - offset).r;
	}

	float luma = (image.Sample(linear_sampler, uv).r + bilinear_sum * 2.0f) / 17.0f;

	return float4(luma, luma, luma, 1.0f);
}

/**
 * @brief Performs per-element multiplication of the R channels of 'image' and 'image1'.
 * @note 'image' and 'image1' must be the same size.
 */
float4 PSMultiplyR8(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;
	float value = image.Sample(point_sampler, uv).r * image1.Sample(point_sampler, uv).r;
	return float4(value, value, value, 1.0f);
}

/**
 * @brief Calculates the square of the R channel of the 'image' texture.
 */
float4 PSSquareR8(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;
	float r = image.Sample(point_sampler, uv).r;
	float value = r * r;
	return float4(value, value, value, 1.0f);
}

/**
 * @brief Calculates the Guided Filter coefficient 'a'.
 * @details Calculates coefficient 'a' based on the formula: a = cov(I, p) / (var(I) + eps),
 * where 'I' is the guide image and 'p' is the input image to be filtered.
 * This is equivalent to: (mean(I*p) - mean(I)*mean(p)) / (mean(I*I) - mean(I)*mean(I) + eps).
 * @param image  Input texture (mean_II: the mean of I*I).
 * @param image1 Input texture (mean_I: the mean of guide image I).
 * @param image2 Input texture (mean_Ip: the mean of I*p).
 * @param image3 Input texture (mean_p: the mean of input image p).
 * @return The calculated coefficient 'a' as a grayscale value.
 * @note All four input textures must be the same (subsampled) resolution.
 */
float4 PSCalculateGuidedFilterA(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float mean_guide_sq = image.Sample(point_sampler, uv).r;
	float mean_guide = image1.Sample(point_sampler, uv).r;
	float mean_guide_source = image2.Sample(point_sampler, uv).r;
	float mean_source = image3.Sample(point_sampler, uv).r;

	float cov_guide_source = mean_guide_source - mean_guide * mean_source;
	float var_guide = mean_guide_sq - mean_guide * mean_guide;

	float value = cov_guide_source / (var_guide + eps);

	return float4(value, value, value, 1.0f);
}

/**
 * @brief Calculates the Guided Filter coefficient 'b'.
 * @details Calculates coefficient 'b' based on the formula: b = mean(p) - a * mean(I),
 * where 'I' is the guide image and 'p' is the input image.
 * @param image  Input texture (coefficient 'a').
 * @param image1 Input texture (mean_p: the mean of input image p).
 * @param image2 Input texture (mean_I: the mean of guide image I).
 * @return The calculated coefficient 'b' as a grayscale value.
 * @note All three input textures must be the same (subsampled) resolution.
 */
float4 PSCalculateGuidedFilterB(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float a = image.Sample(point_sampler, uv).r;
	float mean_source = image1.Sample(point_sampler, uv).r;
	float mean_guide = image2.Sample(point_sampler, uv).r;

	float value = mean_source - a * mean_guide;
	return float4(value, value, value, 1.0f);
}

/**
 * @brief Calculates the final result of the Guided Filter.
 * @details Constructs the final output image using the formula: output = a * I + b.
 * The low-resolution coefficients 'a' and 'b' are upsampled using linear interpolation
 * and applied to the full-resolution guide image 'I'.
 * @param image  Input texture (the full-resolution guide image I).
 * @param image1 Input texture (the subsampled coefficient 'a').
 * @param image2 Input texture (the subsampled coefficient 'b').
 * @return The final filtered pixel value.
 */
float4 PSFinalizeGuidedFilter(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float guide = image.Sample(point_sampler, uv).r;
	float a = image1.Sample(linear_sampler, uv).r;
	float b = image2.Sample(linear_sampler, uv).r;

	float value = a * guide + b;
	return float4(value, value, value, 1.0f);
}

// --- Techniques (Shader pass definitions) ---

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDraw(vert_in);
	}
}

technique DrawWithMask
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDrawWithMask(vert_in);
	}
}

technique ResampleByNearestR8
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSResampleByNearestR8(vert_in);
	}
}

technique ConvertToGrayscale
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSConvertToGrayscale(vert_in);
	}
}

technique HorizontalBoxFilterR8KS17
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalBoxFilterR8KS17(vert_in);
	}
}

technique VerticalBoxFilterR8KS17
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalBoxFilterR8KS17(vert_in);
	}
}

technique MultiplyR8
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSMultiplyR8(vert_in);
	}
}

technique SquareR8
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSSquareR8(vert_in);
	}
}

technique CalculateGuidedFilterA
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateGuidedFilterA(vert_in);
	}
}

technique CalculateGuidedFilterB
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateGuidedFilterB(vert_in);
	}
}

technique FinalizeGuidedFilter
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSFinalizeGuidedFilter(vert_in);
	}
}