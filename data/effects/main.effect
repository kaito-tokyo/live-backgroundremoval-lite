/**
 * @file main.effect
 * @brief Guided Image Filter and related utility shaders.
 * @date 2025-09-16
 * @author Kaito Udagawa
 *
 * This effect file contains all the necessary pixel shaders and techniques
 * for grayscale conversion, box filtering, and a multi-pass implementation
 * of the Guided Image Filter.
 */

// --- Uniforms (Variables set from the host application) ---

uniform float4x4 ViewProj; ///< View-projection matrix for the vertex shader.
uniform texture2d image;   ///< Primary input texture. Its role varies per pass.

// Parameters for the box filter
uniform float texelWidth;  ///< The width of a single texel (1.0 / texture_width).
uniform float texelHeight; ///< The height of a single texel (1.0 / texture_height).
uniform int kernelSize;    ///< The kernel size for the box filter (an odd number is recommended).

// Textures for multi-pass operations
uniform texture2d image1; ///< Secondary input texture.
uniform texture2d image2; ///< Tertiary input texture.
uniform texture2d image3; ///< Quaternary input texture.

uniform float gamma;
uniform float lowerBound;
uniform float upperBound;

// Parameters for the Guided Filter
uniform float eps; ///< A small epsilon value to prevent division by zero when calculating coefficient 'a'.

// --- Sampler States (How textures are sampled) ---

/// @brief Sampler with linear interpolation (Bilinear). Used for filtering and smooth scaling.
sampler_state linear_sampler
{
	Filter = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

/// @brief Sampler without interpolation (Nearest Neighbor). Used for precise data access.
sampler_state point_sampler
{
	Filter = Point;
	AddressU = Clamp;
	AddressV = Clamp;
};

/**
 * @brief Data structure passed from the vertex shader to the pixel shader.
 */
struct VertInOut {
	float4 pos : POSITION; ///< Clip-space position.
	float2 uv : TEXCOORD0; ///< UV texture coordinate.
};

/**
 * @brief A standard vertex shader that transforms vertex positions and passes UV coordinates through.
 */
VertInOut VSDefault(VertInOut vert_in)
{
	VertInOut vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv = vert_in.uv;
	return vert_out;
}

/**
 * @brief Draws the 'image' texture directly.
 */
float4 PSDraw(VertInOut vert_in) : TARGET
{
	return image.Sample(point_sampler, vert_in.uv);
}

/**
 * @brief Draws the final image by combining the RGB from 'image' and using the R channel of 'image1' as the alpha mask.
 * @param image The source texture for RGB color.
 * @param image1 The source texture for the alpha mask (uses the R channel).
 * @note 'image' and 'image1' are expected to be the same size.
 */
float4 PSDrawWithMask(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;
	float4 final_color;

	final_color.rgb = image.Sample(point_sampler, uv).rgb;
	final_color.a = image1.Sample(point_sampler, uv).r;

	return final_color;
}

/**
 * @brief Composites the final image using a perceptually refined alpha matte.
 * @details This shader takes a source color texture and a raw, soft alpha matte.
 * It then applies a two-stage finishing process to the matte before the
 * final composition. First, a gamma correction (`pow`) is applied to control
 * the hardness and falloff of the edges. Second, a contrast enhancement
 * (`smoothstep`) is used to solidify the core of the matte and remove halos,
 * resulting in a clean, sharp, and natural-looking composite.
 * @param image The source texture for RGB color (e.g., the original full-resolution image).
 * @param image1 The source texture for the raw alpha matte (e.g., the soft output from a Guided Filter).
 * @param gamma A uniform float controlling edge hardness. >1.0 makes edges sharper/thinner (choke), <1.0 makes them softer/thicker (spread). A typical value is 1.5-2.5.
 * @param lowerBound A uniform float for the lower threshold of the smoothstep. Values in the matte below this become fully transparent (0.0). Controls halo removal. A typical value is 0.05-0.2.
 * @param upperBound A uniform float for the upper threshold of the smoothstep. Values in the matte above this become fully opaque (1.0). Controls core solidity. A typical value is 0.8-0.95.
 * @return The final composited pixel color (RGBA).
 * @note The textures 'image' and 'image1' are expected to be the same size.
 */
float4 PSDrawWithRefinedMask(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	// 1. Get the original color and the raw mask value
	float3 final_rgb = image.Sample(point_sampler, uv).rgb;
	float raw_mask = image1.Sample(point_sampler, uv).r;

	// 2. Apply gamma correction to adjust the edge falloff
	float gamma_corrected_mask = pow(saturate(raw_mask), gamma);

	// 3. Enhance contrast to solidify the core and remove halos
	float final_alpha = smoothstep(lowerBound, upperBound, gamma_corrected_mask);

	// 4. Return the final composited color
	return float4(final_rgb, final_alpha);
}

float4 PSResampleByNearestR8(VertInOut vert_in) : TARGET
{
	float value = image.Sample(point_sampler, vert_in.uv).r;
	return float4(value, value, value, 1.0f);
}

/**
 * @brief Converts the 'image' texture to grayscale using the standard luma calculation.
 */
float4 PSConvertToGrayscale(VertInOut vert_in) : TARGET
{
	float4 color = image.Sample(point_sampler, vert_in.uv);
	float luma = dot(color.rgb, float3(0.2126, 0.7152, 0.0722));
	return float4(luma, luma, luma, 1.0f);
}

/**
 * @brief Calculates the difference between two grayscale images, considering a mask, for the first pass of a reduction.
 * @details This shader computes the absolute luminance difference between the current and last frames,
 * but only for regions where the mask value is greater than 0.1 (likely the subject).
 * This isolates changes related to the subject's movement and ignores background noise.
 * @param image  Input texture (current downsampled grayscale image).
 * @param image1 Input texture (last downsampled grayscale image).
 * @param image2 Input texture (segmentation mask).
 * @return Returns the luminance difference for pixels within the masked area; otherwise, returns black (0).
 */
float4 PSCalculateMaskedDifferenceR(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float current_luma = image.Sample(point_sampler, uv).r;
	float last_luma    = image1.Sample(point_sampler, uv).r;
	float mask         = image2.Sample(point_sampler, uv).r;

	float weight = step(0.1, mask);

	float diff = abs(current_luma - last_luma);

	float final_diff = diff * weight;

	return float4(final_diff, final_diff, final_diff, 1.0f);
}

/**
 * @brief Reduces a texture by summing 2x2 pixel blocks using an optimized bilinear sample.
 * @details This shader downsamples an input texture to half its size. It calculates the sum
 * of a 2x2 pixel block by performing a single bilinear texture fetch from the center of the block,
 * which returns the average of the four pixels. This average is then multiplied by 4 to get the sum.
 * This method significantly reduces texture fetches from 4 to 1 per pixel.
 * @param image Input texture to be reduced. The .r channel is expected to contain the value.
 * @return The sum of a 2x2 block of pixels, stored in all RGBA channels.
 */
float4 PSReduce(VertInOut vert_in) : TARGET
{
	// A single bilinear sample from the center of a 2x2 texel area
	// returns the average of those four texels. The C++ side ensures the UV
	// coordinates align correctly for this operation.
	float average = image.Sample(linear_sampler, vert_in.uv).r;

	// Multiply the average by 4.0 to get the sum.
	float sum = average * 4.0;

	return float4(sum, sum, sum, 1.0f);
}

/**
 * @brief Applies an optimized 1D horizontal box filter with a fixed kernel size of 17.
 * (Pass 1 of a separable filter)
 */
float4 PSHorizontalBoxFilterR8KS17(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;
	float halfTexelWidth = texelWidth / 2.0f;

	float bilinear_sum = 0.0f;
	for (int i = 1; i <= 4; i++) {
		float2 offset = float2((i * 4 - 1) * halfTexelWidth, 0.0f);
		bilinear_sum += image.Sample(linear_sampler, uv + offset).r;
		bilinear_sum += image.Sample(linear_sampler, uv - offset).r;
	}

	float luma = (image.Sample(linear_sampler, uv).r + bilinear_sum * 2.0f) / 17.0f;

	return float4(luma, luma, luma, 1.0f);
}

/**
 * @brief Combines per-element multiplication and a 1D horizontal box filter (KS=17).
 * (Pass 1 of a separable filter)
 * @note This shader combines the operations of PSMultiplyR8 and PSHorizontalBoxFilterR8KS17.
 */
float4 PSHorizontalBoxFilterWithMulR8KS17(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float sum = image.Sample(point_sampler, uv).r * image1.Sample(point_sampler, uv).r;
	for (int i = 1; i <= 8; i++) {
		float2 offset = float2(i * texelWidth, 0.0f);
		sum += image.Sample(point_sampler, uv + offset).r * image1.Sample(point_sampler, uv + offset).r;
		sum += image.Sample(point_sampler, uv - offset).r * image1.Sample(point_sampler, uv - offset).r;
	}

	float luma = sum / 17.0f;

	return float4(luma, luma, luma, 1.0f);
}

float square(float x)
{
	return x * x;
}

/**
 * @brief Combines squaring and a 1D horizontal box filter (KS=17).
 * (Pass 1 of a separable filter)
 * @note This shader combines the operations of PSSquareR8 and PSHorizontalBoxFilterR8KS17.
 */
float4 PSHorizontalBoxFilterWithSqR8KS17(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float sum = square(image.Sample(point_sampler, uv).r);
	for (int i = 1; i <= 8; i++) {
		float2 offset = float2(i * texelWidth, 0.0f);
		sum += square(image.Sample(point_sampler, uv + offset).r);
		sum += square(image.Sample(point_sampler, uv - offset).r);
	}

	float luma = sum / 17.0f;

	return float4(luma, luma, luma, 1.0f);
}

/**
 * @brief Applies an optimized 1D vertical box filter with a fixed kernel size of 17.
 * (Pass 2 of a separable filter)
 */
float4 PSVerticalBoxFilterR8KS17(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;
	float halfTexelHeight = texelHeight / 2.0f;

	float bilinear_sum = 0.0f;
	for (int i = 1; i <= 4; i++) {
		float2 offset = float2(0.0f, (i * 4 - 1) * halfTexelHeight);
		bilinear_sum += image.Sample(linear_sampler, uv + offset).r;
		bilinear_sum += image.Sample(linear_sampler, uv - offset).r;
	}

	float luma = (image.Sample(linear_sampler, uv).r + bilinear_sum * 2.0f) / 17.0f;

	return float4(luma, luma, luma, 1.0f);
}

/**
 * @brief Calculates the Guided Filter coefficient 'a'.
 * @details Calculates coefficient 'a' based on the formula: a = cov(I, p) / (var(I) + eps),
 * where 'I' is the guide image and 'p' is the input image to be filtered.
 * This is equivalent to: (mean(I*p) - mean(I)*mean(p)) / (mean(I*I) - mean(I)*mean(I) + eps).
 * @param image  Input texture (mean_II: the mean of I*I).
 * @param image1 Input texture (mean_I: the mean of guide image I).
 * @param image2 Input texture (mean_Ip: the mean of I*p).
 * @param image3 Input texture (mean_p: the mean of input image p).
 * @return The calculated coefficient 'a' as a grayscale value.
 * @note All four input textures must be the same (subsampled) resolution.
 */
float4 PSCalculateGuidedFilterA(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float mean_guide_sq = image.Sample(point_sampler, uv).r;
	float mean_guide = image1.Sample(point_sampler, uv).r;
	float mean_guide_source = image2.Sample(point_sampler, uv).r;
	float mean_source = image3.Sample(point_sampler, uv).r;

	float cov_guide_source = mean_guide_source - mean_guide * mean_source;
	float var_guide = mean_guide_sq - mean_guide * mean_guide;

	float value = cov_guide_source / (var_guide + eps);

	return float4(value, value, value, 1.0f);
}

/**
 * @brief Calculates the Guided Filter coefficient 'b'.
 * @details Calculates coefficient 'b' based on the formula: b = mean(p) - a * mean(I),
 * where 'I' is the guide image and 'p' is the input image.
 * @param image  Input texture (coefficient 'a').
 * @param image1 Input texture (mean_p: the mean of input image p).
 * @param image2 Input texture (mean_I: the mean of guide image I).
 * @return The calculated coefficient 'b' as a grayscale value.
 * @note All three input textures must be the same (subsampled) resolution.
 */
float4 PSCalculateGuidedFilterB(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float a = image.Sample(point_sampler, uv).r;
	float mean_source = image1.Sample(point_sampler, uv).r;
	float mean_guide = image2.Sample(point_sampler, uv).r;

	float value = mean_source - a * mean_guide;
	return float4(value, value, value, 1.0f);
}

/**
 * @brief Calculates the final result of the Guided Filter.
 * @details Constructs the final output image using the formula: output = a * I + b.
 * The low-resolution coefficients 'a' and 'b' are upsampled using linear interpolation
 * and applied to the full-resolution guide image 'I'.
 * @param image  Input texture (the full-resolution guide image I).
 * @param image1 Input texture (the subsampled coefficient 'a').
 * @param image2 Input texture (the subsampled coefficient 'b').
 * @return The final filtered pixel value.
 */
float4 PSFinalizeGuidedFilter(VertInOut vert_in) : TARGET
{
	float2 uv = vert_in.uv;

	float guide = image.Sample(point_sampler, uv).r;
	float a = image1.Sample(linear_sampler, uv).r;
	float b = image2.Sample(linear_sampler, uv).r;

	float value = a * guide + b;
	return float4(value, value, value, 1.0f);
}

// --- Techniques (Shader pass definitions) ---

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDraw(vert_in);
	}
}

technique DrawWithMask
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDrawWithMask(vert_in);
	}
}

technique DrawWithRefinedMask
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDrawWithRefinedMask(vert_in);
	}
}

technique ResampleByNearestR8
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSResampleByNearestR8(vert_in);
	}
}

technique ConvertToGrayscale
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSConvertToGrayscale(vert_in);
	}
}

technique CalculateDifferenceWithMask
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateMaskedDifferenceR(vert_in);
	}
}

technique Reduce
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSReduce(vert_in);
	}
}

technique HorizontalBoxFilterR8KS17
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalBoxFilterR8KS17(vert_in);
	}
}

technique HorizontalBoxFilterWithMulR8KS17
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalBoxFilterWithMulR8KS17(vert_in);
	}
}

technique HorizontalBoxFilterWithSqR8KS17
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalBoxFilterWithSqR8KS17(vert_in);
	}
}

technique VerticalBoxFilterR8KS17
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalBoxFilterR8KS17(vert_in);
	}
}

technique CalculateGuidedFilterA
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateGuidedFilterA(vert_in);
	}
}

technique CalculateGuidedFilterB
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateGuidedFilterB(vert_in);
	}
}

technique FinalizeGuidedFilter
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSFinalizeGuidedFilter(vert_in);
	}
}