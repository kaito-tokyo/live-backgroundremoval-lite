name: 'ðŸ”€ Gemini Triage'

on:
  workflow_call:
    inputs:
      additional_context:
        type: 'string'
        description: 'Any additional context from the request'
        required: false

concurrency:
  group: '${{ github.workflow }}-triage-${{ github.event_name }}-${{ github.event.pull_request.number || github.event.issue.number }}'
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

jobs:
  triage:
    runs-on: 'ubuntu-latest'
    timeout-minutes: 7
    outputs:
      selected_labels: '${{ steps.parse_response.outputs.labels_csv }}'
      available_labels: '${{ steps.get_labels.outputs.available_labels }}'
    permissions:
      contents: 'read'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'read'
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Get repository labels'
        id: 'get_labels'
        uses: 'actions/github-script@v7'
        with:
          script: |
            const { data: labels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            if (!labels || labels.length === 0) {
              core.setFailed('There are no issue labels in this repository.')
            }
            const labelNames = labels.map(label => label.name).sort();
            core.setOutput('available_labels', labelNames.join(','));

      - name: Read Context Files
        id: read_docs
        run: |
          CONTEXT_DATA=""
          FILES_TO_READ=("README.md" "GEMINI.md" "CONTRIBUTING.md")
          for FILE in "${FILES_TO_READ[@]}"; do
            if [[ -f "$FILE" ]]; then
              # ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ãªãŒã‚‰èª­ã¿è¾¼ã‚€
              ESCAPED_CONTENT=$(cat "$FILE" | sed -e ':a' -e 'N' -e '$!ba' -e 's/\\/\\\\/g' -e 's/%/%25/g' -e 's/\n/%0A/g' -e 's/\r/%0D/g')
              CONTEXT_DATA="${CONTEXT_DATA}\n\n---\n\n# Content from ${FILE}:\n\n${ESCAPED_CONTENT}"
            fi
          done
          echo "context=${CONTEXT_DATA}" >> $GITHUB_OUTPUT

      - name: Detect Language
        id: detect_lang
        uses: google-github-actions/run-gemini-cli@v1
        with:
          model: 'gemini-1.5-flash-latest'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          prompt: |
            Analyze the following text and identify its primary language.
            Respond with ONLY ONE of the following: "Japanese", "English", or "Other".
            ---
            Title: ${{ github.event.issue.title }}
            Body: ${{ github.event.issue.body }}

      # --- ã“ã“ã‹ã‚‰ãŒé‡è¦ãªä¿®æ­£ç®‡æ‰€ã§ã™ ---
      - name: Prepare Prompt
        id: prepare_prompt
        uses: actions/github-script@v7
        with:
          script: |
            const lang = "${{ steps.detect_lang.outputs.response }}".trim();
            const author = "${{ github.event.issue.user.login }}";
            const issueTitle = `${{ github.event.issue.title }}`;
            const issueBody = `${{ github.event.issue.body }}`;
            const repoContext = `${{ steps.read_docs.outputs.context }}`;
            const availableLabels = "${{ steps.get_labels.outputs.available_labels }}".split(',');
            
            let commentInstructions = '';
            let labelsInstruction = `Choose relevant labels from this list: ${JSON.stringify(availableLabels)}`;

            if (lang === "Japanese") {
              commentInstructions = `ã‚ãªãŸã¯è¦ªåˆ‡ãªAIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚æ—¥æœ¬ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã€ä¸å¯§ã§æ­“è¿Žã•ã‚Œã¦ã„ã‚‹ã¨æ„Ÿã˜ã‚‰ã‚Œã‚‹ã‚³ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚\n\n**ã‚³ãƒ¡ãƒ³ãƒˆç”Ÿæˆã®æŒ‡ç¤º:**\n1. @${author} ã•ã‚“ã§å§‹ã‚ã‚‹ã€‚2. Issueå ±å‘Šã¸ã®æ„Ÿè¬ã‚’è¿°ã¹ã‚‹ã€‚3. å†…å®¹ã‚’ç†è§£ã—ãŸã“ã¨ã‚’ç¤ºã—ã€ãƒãƒ¼ãƒ ãŒç¢ºèªã™ã‚‹ã“ã¨ã‚’ä¼ãˆã‚‹ã€‚`;
            } else if (lang === "English") {
              commentInstructions = `You are a friendly AI assistant. Create a welcoming and helpful comment for the user in English.\n\n**Comment Generation Instructions:**\n1. Start with "Hi @${author}". 2. Thank them for the issue. 3. Acknowledge you understand the report and that the team will review it.`;
            } else { // Other
              commentInstructions = `You are a friendly AI assistant. Create a polite apology in English as we cannot support the user's language.\n\n**Comment Generation Instructions:**\n1. Thank the user for the report. 2. Apologize and state that we can only support English or Japanese at this time. 3. Ask if they can resubmit in one of those languages.`;
              labelsInstruction = 'Choose ONLY from this list: ["needs-translation"]';
            }

            const finalPrompt = `
            # Task: Generate two parts: a user-facing comment and a machine-readable list of labels, separated by '---JSON_LABELS---'.
            
            # Part 1: The user-facing comment.
            ${commentInstructions}
            
            # Repository Context for your response:
            ${repoContext}

            # Issue Details:
            Author: @${author}
            Title: ${issueTitle}
            Body: ${issueBody}

            ---JSON_LABELS---

            # Part 2: Triage Labels in JSON format.
            # Analyze the issue. ${labelsInstruction}
            # Respond with a valid JSON object like: {"labels": ["bug", "enhancement"]}
            `;
            
            core.setOutput('full_prompt', finalPrompt);

      - name: Generate Response and Labels
        id: gemini_response
        uses: google-github-actions/run-gemini-cli@v1
        with:
          model: 'gemini-1.5-flash-latest'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          prompt: ${{ steps.prepare_prompt.outputs.full_prompt }}

      - name: Parse Response and Post Comment
        id: parse_response
        uses: actions/github-script@v7
        with:
          script: |
            const responseBody = `${{ steps.gemini_response.outputs.response }}`;
            const parts = responseBody.split('---JSON_LABELS---');
            const comment = parts[0] ? parts[0].trim() : '';
            const labelsJsonString = parts[1] ? parts[1].trim() : '{"labels": []}';
            
            let labels = [];
            try {
              const parsedJson = JSON.parse(labelsJsonString);
              labels = parsedJson.labels || [];
            } catch (e) {
              core.warning("Could not parse labels from Gemini response: " + e.message);
            }

            // Post Comment
            if (comment) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
            
            // Set outputs for the next job
            core.setOutput('labels_csv', labels.join(','));

  label:
    runs-on: 'ubuntu-latest'
    needs:
      - 'triage'
    if: |-
      ${{ needs.triage.outputs.selected_labels != '' }}
    permissions:
      issues: 'write'
    steps:
      - name: 'Apply labels'
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          script: |
            const availableLabels = "${{ needs.triage.outputs.available_labels }}".split(',');
            const selectedLabels = "${{ needs.triage.outputs.selected_labels }}".split(',')
              .map(label => label.trim())
              .filter(label => label && availableLabels.includes(label));

            if (selectedLabels.length > 0) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: selectedLabels,
              });
              core.info(`Successfully set labels: ${selectedLabels.join(',')}`);
            } else {
              core.info(`No valid labels were selected to set.`);
            }
