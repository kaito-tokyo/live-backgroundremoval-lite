name: '🔀 Gemini Triage'

on:
  workflow_call:
    inputs:
      additional_context:
        type: 'string'
        description: 'Any additional context from the request'
        required: false

concurrency:
  group: '${{ github.workflow }}-triage-${{ github.event_name }}-${{ github.event.pull_request.number || github.event.issue.number }}'
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

jobs:
  triage:
    runs-on: 'ubuntu-latest'
    timeout-minutes: 7
    outputs:
      selected_labels: '${{ steps.parse_response.outputs.labels_csv }}'
      available_labels: '${{ steps.get_labels.outputs.available_labels }}'
    permissions:
      contents: 'read'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'read'
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Get repository labels'
        id: 'get_labels'
        uses: 'actions/github-script@v7'
        with:
          script: |
            const { data: labels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            if (!labels || labels.length === 0) {
              core.setFailed('There are no issue labels in this repository.')
            }
            const labelNames = labels.map(label => label.name).sort();
            core.setOutput('available_labels', labelNames.join(','));

      - name: Read Context Files
        id: read_docs
        run: |
          CONTEXT_DATA=""
          FILES_TO_READ=("README.md" "GEMINI.md" "CONTRIBUTING.md")
          for FILE in "${FILES_TO_READ[@]}"; do
            if [[ -f "$FILE" ]]; then
              # ファイルの内容をエスケープしながら読み込む
              ESCAPED_CONTENT=$(cat "$FILE" | sed -e ':a' -e 'N' -e '$!ba' -e 's/\\/\\\\/g' -e 's/%/%25/g' -e 's/\n/%0A/g' -e 's/\r/%0D/g')
              CONTEXT_DATA="${CONTEXT_DATA}\n\n---\n\n# Content from ${FILE}:\n\n${ESCAPED_CONTENT}"
            fi
          done
          echo "context=${CONTEXT_DATA}" >> $GITHUB_OUTPUT

      - name: Detect Language
        id: detect_lang
        uses: google-github-actions/run-gemini-cli@v1
        with:
          model: 'gemini-1.5-flash-latest'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          prompt: |
            Analyze the following text and identify its primary language.
            Respond with ONLY ONE of the following: "Japanese", "English", or "Other".
            ---
            Title: ${{ github.event.issue.title }}
            Body: ${{ github.event.issue.body }}

      # --- ここからが重要な修正箇所です ---
      - name: Prepare Prompt
        id: prepare_prompt
        uses: actions/github-script@v7
        with:
          script: |
            const lang = "${{ steps.detect_lang.outputs.response }}".trim();
            const author = "${{ github.event.issue.user.login }}";
            const issueTitle = `${{ github.event.issue.title }}`;
            const issueBody = `${{ github.event.issue.body }}`;
            const repoContext = `${{ steps.read_docs.outputs.context }}`;
            const availableLabels = "${{ steps.get_labels.outputs.available_labels }}".split(',');
            
            let commentInstructions = '';
            let labelsInstruction = `Choose relevant labels from this list: ${JSON.stringify(availableLabels)}`;

            if (lang === "Japanese") {
              commentInstructions = `あなたは親切なAIアシスタントです。日本のユーザーに、丁寧で歓迎されていると感じられるコメントを作成してください。\n\n**コメント生成の指示:**\n1. @${author} さんで始める。2. Issue報告への感謝を述べる。3. 内容を理解したことを示し、チームが確認することを伝える。`;
            } else if (lang === "English") {
              commentInstructions = `You are a friendly AI assistant. Create a welcoming and helpful comment for the user in English.\n\n**Comment Generation Instructions:**\n1. Start with "Hi @${author}". 2. Thank them for the issue. 3. Acknowledge you understand the report and that the team will review it.`;
            } else { // Other
              commentInstructions = `You are a friendly AI assistant. Create a polite apology in English as we cannot support the user's language.\n\n**Comment Generation Instructions:**\n1. Thank the user for the report. 2. Apologize and state that we can only support English or Japanese at this time. 3. Ask if they can resubmit in one of those languages.`;
              labelsInstruction = 'Choose ONLY from this list: ["needs-translation"]';
            }

            const finalPrompt = `
            # Task: Generate two parts: a user-facing comment and a machine-readable list of labels, separated by '---JSON_LABELS---'.
            
            # Part 1: The user-facing comment.
            ${commentInstructions}
            
            # Repository Context for your response:
            ${repoContext}

            # Issue Details:
            Author: @${author}
            Title: ${issueTitle}
            Body: ${issueBody}

            ---JSON_LABELS---

            # Part 2: Triage Labels in JSON format.
            # Analyze the issue. ${labelsInstruction}
            # Respond with a valid JSON object like: {"labels": ["bug", "enhancement"]}
            `;
            
            core.setOutput('full_prompt', finalPrompt);

      - name: Generate Response and Labels
        id: gemini_response
        uses: google-github-actions/run-gemini-cli@v1
        with:
          model: 'gemini-1.5-flash-latest'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          prompt: ${{ steps.prepare_prompt.outputs.full_prompt }}

      - name: Parse Response and Post Comment
        id: parse_response
        uses: actions/github-script@v7
        with:
          script: |
            const responseBody = `${{ steps.gemini_response.outputs.response }}`;
            const parts = responseBody.split('---JSON_LABELS---');
            const comment = parts[0] ? parts[0].trim() : '';
            const labelsJsonString = parts[1] ? parts[1].trim() : '{"labels": []}';
            
            let labels = [];
            try {
              const parsedJson = JSON.parse(labelsJsonString);
              labels = parsedJson.labels || [];
            } catch (e) {
              core.warning("Could not parse labels from Gemini response: " + e.message);
            }

            // Post Comment
            if (comment) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
            
            // Set outputs for the next job
            core.setOutput('labels_csv', labels.join(','));

  label:
    runs-on: 'ubuntu-latest'
    needs:
      - 'triage'
    if: |-
      ${{ needs.triage.outputs.selected_labels != '' }}
    permissions:
      issues: 'write'
    steps:
      - name: 'Apply labels'
        uses: actions/github-script@v7
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          script: |
            const availableLabels = "${{ needs.triage.outputs.available_labels }}".split(',');
            const selectedLabels = "${{ needs.triage.outputs.selected_labels }}".split(',')
              .map(label => label.trim())
              .filter(label => label && availableLabels.includes(label));

            if (selectedLabels.length > 0) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: selectedLabels,
              });
              core.info(`Successfully set labels: ${selectedLabels.join(',')}`);
            } else {
              core.info(`No valid labels were selected to set.`);
            }
